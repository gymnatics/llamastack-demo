# Official GitHub MCP Server
# Based on: https://github.com/modelcontextprotocol/servers/tree/main/src/github
# Uses @modelcontextprotocol/server-github npm package
---
apiVersion: v1
kind: Secret
metadata:
  name: github-mcp-token
  namespace: my-first-model
  labels:
    app: github-mcp-server
    app.kubernetes.io/name: github-mcp-server
    app.kubernetes.io/part-of: llamastack-mcp-demo
type: Opaque
stringData:
  # Replace with your GitHub Personal Access Token
  # Create one at: https://github.com/settings/tokens
  GITHUB_PERSONAL_ACCESS_TOKEN: "YOUR_GITHUB_TOKEN_HERE"
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: github-mcp-server
  namespace: my-first-model
  labels:
    app: github-mcp-server
    app.kubernetes.io/name: github-mcp-server
    app.kubernetes.io/part-of: llamastack-mcp-demo
spec:
  replicas: 1
  selector:
    matchLabels:
      app: github-mcp-server
  template:
    metadata:
      labels:
        app: github-mcp-server
    spec:
      containers:
      - name: github-mcp-server
        image: python:3.11-slim
        command: ["/bin/sh", "-c"]
        args:
        - |
          # Install dependencies
          apt-get update && apt-get install -y nodejs npm curl git --no-install-recommends
          
          # Set npm cache to writable directory
          export HOME=/tmp
          export npm_config_cache=/tmp/.npm
          mkdir -p /tmp/.npm /tmp/app
          cd /tmp/app
          
          echo "Installing MCP packages..."
          npm init -y
          npm install @modelcontextprotocol/server-github
          
          # Install Python MCP dependencies
          pip install mcp uvicorn httpx
          
          # Create a simple HTTP wrapper for the GitHub MCP server
          cat > /tmp/app/server.py << 'PYEOF'
          import asyncio
          import json
          import subprocess
          import os
          from mcp.server.fastmcp import FastMCP
          from mcp.server.transport_security import TransportSecuritySettings
          import httpx

          # GitHub API configuration
          GITHUB_TOKEN = os.getenv("GITHUB_PERSONAL_ACCESS_TOKEN")
          GITHUB_API = "https://api.github.com"

          transport_security = TransportSecuritySettings(enable_dns_rebinding_protection=False)
          mcp = FastMCP("github-tools", transport_security=transport_security)

          headers = {
              "Authorization": f"Bearer {GITHUB_TOKEN}",
              "Accept": "application/vnd.github+json",
              "X-GitHub-Api-Version": "2022-11-28"
          }

          @mcp.tool()
          async def search_repositories(query: str, per_page: int = 10) -> str:
              """Search for GitHub repositories.
              
              Args:
                  query: Search query (e.g., 'kubernetes language:python')
                  per_page: Number of results (max 100)
              """
              async with httpx.AsyncClient() as client:
                  response = await client.get(
                      f"{GITHUB_API}/search/repositories",
                      params={"q": query, "per_page": min(per_page, 100)},
                      headers=headers,
                      timeout=30
                  )
                  if response.status_code != 200:
                      return f"Error: {response.status_code} - {response.text}"
                  
                  data = response.json()
                  results = []
                  for repo in data.get("items", [])[:per_page]:
                      results.append(f"ğŸ“¦ {repo['full_name']} â­ {repo['stargazers_count']}\n   {repo.get('description', 'No description')[:100]}\n   ğŸ”— {repo['html_url']}")
                  
                  return f"Found {data['total_count']} repositories:\n\n" + "\n\n".join(results)

          @mcp.tool()
          async def get_repository(owner: str, repo: str) -> str:
              """Get details about a specific repository.
              
              Args:
                  owner: Repository owner (username or org)
                  repo: Repository name
              """
              async with httpx.AsyncClient() as client:
                  response = await client.get(
                      f"{GITHUB_API}/repos/{owner}/{repo}",
                      headers=headers,
                      timeout=30
                  )
                  if response.status_code != 200:
                      return f"Error: {response.status_code} - {response.text}"
                  
                  r = response.json()
                  return f"""ğŸ“¦ {r['full_name']}
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          ğŸ“ {r.get('description', 'No description')}
          
          â­ Stars: {r['stargazers_count']}
          ğŸ´ Forks: {r['forks_count']}
          ğŸ‘ï¸ Watchers: {r['watchers_count']}
          ğŸ› Open Issues: {r['open_issues_count']}
          
          ğŸ“… Created: {r['created_at'][:10]}
          ğŸ“… Updated: {r['updated_at'][:10]}
          
          ğŸ”— URL: {r['html_url']}
          ğŸ  Homepage: {r.get('homepage') or 'None'}
          ğŸ“œ License: {r.get('license', {}).get('name', 'None')}
          ğŸ—£ï¸ Language: {r.get('language', 'Unknown')}
          """

          @mcp.tool()
          async def list_issues(owner: str, repo: str, state: str = "open", per_page: int = 10) -> str:
              """List issues in a repository.
              
              Args:
                  owner: Repository owner
                  repo: Repository name
                  state: Issue state (open, closed, all)
                  per_page: Number of results
              """
              async with httpx.AsyncClient() as client:
                  response = await client.get(
                      f"{GITHUB_API}/repos/{owner}/{repo}/issues",
                      params={"state": state, "per_page": per_page},
                      headers=headers,
                      timeout=30
                  )
                  if response.status_code != 200:
                      return f"Error: {response.status_code} - {response.text}"
                  
                  issues = response.json()
                  if not issues:
                      return f"No {state} issues found in {owner}/{repo}"
                  
                  results = []
                  for issue in issues:
                      labels = ", ".join([l['name'] for l in issue.get('labels', [])])
                      results.append(f"#{issue['number']} {issue['title']}\n   State: {issue['state']} | Labels: {labels or 'None'}\n   By: {issue['user']['login']} | Comments: {issue['comments']}")
                  
                  return f"Issues in {owner}/{repo} ({state}):\n\n" + "\n\n".join(results)

          @mcp.tool()
          async def create_issue(owner: str, repo: str, title: str, body: str = "", labels: str = "") -> str:
              """Create a new issue in a repository.
              
              Args:
                  owner: Repository owner
                  repo: Repository name
                  title: Issue title
                  body: Issue body/description
                  labels: Comma-separated labels
              """
              async with httpx.AsyncClient() as client:
                  data = {"title": title, "body": body}
                  if labels:
                      data["labels"] = [l.strip() for l in labels.split(",")]
                  
                  response = await client.post(
                      f"{GITHUB_API}/repos/{owner}/{repo}/issues",
                      json=data,
                      headers=headers,
                      timeout=30
                  )
                  if response.status_code not in [200, 201]:
                      return f"Error: {response.status_code} - {response.text}"
                  
                  issue = response.json()
                  return f"âœ… Issue created successfully!\n\n#{issue['number']} {issue['title']}\nğŸ”— {issue['html_url']}"

          @mcp.tool()
          async def search_code(query: str, per_page: int = 10) -> str:
              """Search for code across GitHub repositories.
              
              Args:
                  query: Search query (e.g., 'fastapi repo:tiangolo/fastapi')
                  per_page: Number of results
              """
              async with httpx.AsyncClient() as client:
                  response = await client.get(
                      f"{GITHUB_API}/search/code",
                      params={"q": query, "per_page": min(per_page, 100)},
                      headers=headers,
                      timeout=30
                  )
                  if response.status_code != 200:
                      return f"Error: {response.status_code} - {response.text}"
                  
                  data = response.json()
                  results = []
                  for item in data.get("items", [])[:per_page]:
                      results.append(f"ğŸ“„ {item['path']}\n   ğŸ“¦ {item['repository']['full_name']}\n   ğŸ”— {item['html_url']}")
                  
                  return f"Found {data['total_count']} code matches:\n\n" + "\n\n".join(results)

          @mcp.tool()
          async def get_user(username: str) -> str:
              """Get information about a GitHub user.
              
              Args:
                  username: GitHub username
              """
              async with httpx.AsyncClient() as client:
                  response = await client.get(
                      f"{GITHUB_API}/users/{username}",
                      headers=headers,
                      timeout=30
                  )
                  if response.status_code != 200:
                      return f"Error: {response.status_code} - {response.text}"
                  
                  u = response.json()
                  return f"""ğŸ‘¤ {u['login']} {f"({u['name']})" if u.get('name') else ''}
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          ğŸ“ {u.get('bio', 'No bio')}
          
          ğŸ“¦ Public Repos: {u['public_repos']}
          ğŸ‘¥ Followers: {u['followers']}
          ğŸ‘¤ Following: {u['following']}
          
          ğŸ¢ Company: {u.get('company', 'None')}
          ğŸ“ Location: {u.get('location', 'None')}
          ğŸ”— Blog: {u.get('blog') or 'None'}
          
          ğŸ“… Joined: {u['created_at'][:10]}
          ğŸ”— Profile: {u['html_url']}
          """

          if __name__ == "__main__":
              import uvicorn
              print("Starting GitHub MCP Server on port 8000...")
              app = mcp.streamable_http_app()
              uvicorn.run(app, host='0.0.0.0', port=8000)
          PYEOF
          
          echo "Starting GitHub MCP Server..."
          python /tmp/app/server.py
        ports:
        - containerPort: 8000
          name: http
        env:
        - name: GITHUB_PERSONAL_ACCESS_TOKEN
          valueFrom:
            secretKeyRef:
              name: github-mcp-token
              key: GITHUB_PERSONAL_ACCESS_TOKEN
        resources:
          requests:
            memory: "512Mi"
            cpu: "200m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        livenessProbe:
          tcpSocket:
            port: 8000
          initialDelaySeconds: 120
          periodSeconds: 30
          failureThreshold: 5
        readinessProbe:
          tcpSocket:
            port: 8000
          initialDelaySeconds: 90
          periodSeconds: 10
---
apiVersion: v1
kind: Service
metadata:
  name: github-mcp-server
  namespace: my-first-model
  labels:
    app: github-mcp-server
spec:
  selector:
    app: github-mcp-server
  ports:
  - name: http
    protocol: TCP
    port: 8000
    targetPort: 8000
---
apiVersion: route.openshift.io/v1
kind: Route
metadata:
  name: github-mcp-server
  namespace: my-first-model
  labels:
    app: github-mcp-server
spec:
  to:
    kind: Service
    name: github-mcp-server
  port:
    targetPort: http
  tls:
    termination: edge
    insecureEdgeTerminationPolicy: Allow
